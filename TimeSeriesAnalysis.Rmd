---
title: "Time Series Analysis"
output: html_notebook
---

Exploring Time Series 

Date: Oct. 6, 2016

References: Datacamp

---------------------------

Start by looking at raw time series

```{r}
print(Nile)
```

Data about the water flow in river Nile from 1871 to 1970

```{r}
length(Nile)
```

```{r}
head(Nile)
```

displaying first few values using head

```{r}
head(Nile, n = 10)
```

Displaying the last few values using the tail command

```{r}
tail(Nile)
```

```{r}
plot(Nile, xlab = 'Year', ylab = 'River Volume (1e9 m^{3})', main = 'Annual River Nile Volume at Aswan, 1871-1970')
```

Plotting both points and the line

```{r}
plot(Nile, xlab = 'Year', ylab = 'River Volume (1e9 m^{3})', main = 'Annual River Nile Volume at Aswan, 1871-1970',  type = 'b')
# b stands for both: line and points
```

Next look at another data set AirPassengers: The classic Box & Jenkins airline data. Monthly totals of international airline passengers, 1949 to 1960.

```{r}
print(AirPassengers)
```


Exploring some of the built-in commands on the AirPassengers data set

"The start() and end() functions return the time index of the first and last observations. 
The time() function calculates a vector of time indices, with one element for each time index on which the series was observed.
The frequency() function returns the number of observations per unit time and the deltat() function returns the fixed time interval between observations. 
The cycle() function returns the position in the cycle of each observation."

```{r}
start(AirPassengers)

end(AirPassengers)
```

```{r}
time(AirPassengers)
```
```{r}
frequency(AirPassengers)
```

```{r}
deltat(AirPassengers)
```

Basically deltat = 1/ frequency

```{r}
cycle(AirPassengers)
```

```{r}
mean(AirPassengers)
```

```{r}
A <- c (1, 2, 3)
A
```

Let's explore the ts command

Construct a sample vector and convert it into ts object
The vector can be created using the c command
```{r}
sample_vector <- c(2.0521941073,  4.2928852797,  3.3294132944,  3.5085950670,  0.0009576938,
   1.9217186345,  0.7978134128,  0.2999543435,  0.9435687536,  0.5748283388,
 -0.0034005903,  0.3448649176,  2.2229761136,  0.1763144576,  2.7097622770,
  1.2501948965, -0.4007164754,  0.8852732121, -1.5852420266, -2.2829278891,
 -2.5609531290, -3.1259963754, -2.8660295895, -1.7847009207, -1.8894912908,
 -2.7255351194, -2.1033141800, -0.0174256893, -0.3613204151, -2.9008403327,
 -3.2847440927, -2.8684594718, -1.9505074437, -4.8801892525, -3.2634605353,
 -1.6396062522, -3.3012575840, -2.6331245433, -1.7058354022, -2.2119825061,
 -0.5170595186,  0.0752508095, -0.8406994716, -1.4022683487, -0.1382114230,
 -1.4065954703, -2.3046941055,  1.5073891432,  0.7118679477, -1.1300519022)
```

```{r}
plot(sample_vector)
```

Now let's convert the sample_vector into a time series object. 

"The function ts() can be applied to create time series objects. A time series object is a vector (univariate) or matrix (multivariate) with additional attributes, including time indices for each observation, the sampling frequency and time increment between observations, and the cycle length for periodic data. Such objects are of the ts class, and represent data that has been observed at (approximately) equally spaced time points. 

The advantage of creating and working with time series objects of the ts class is that many methods are available for utilizing time series attributes, such as time index information. For example, calling plot() on a ts object will automatically generate a plot over time."

```{r}
time_series <- ts(sample_vector)
plot(time_series, type = 'p')
```


```{r}
length(sample_vector)
```

The default starting point is 1 and the default deltat is 1 as well. 

```{r}
time_series <- ts(sample_vector, start = 2000, frequency = 4)
plot(time_series)
```
```{r}
time(time_series)
```

```{r}
time_series <- ts(sample_vector, start = 2000, deltat = 4)
plot(time_series)
```
```{r}
time(time_series)
```
```{r}
time_series <- ts(sample_vector, start = 2000, deltat = 0.25)
plot(time_series)
```

```{r}
time(time_series)
```

```{r}
print(time_series)

print(sample_vector)
```

The neat is.ts() command
```{r}
is.ts(time_series)
is.ts(sample_vector)
is.ts(Nile)
is.ts(AirPassengers)
```

Exploring the EU stocks data

```{r}
print(EuStockMarkets)
```


```{r}
head(EuStockMarkets, n = 132)
```
```{r}
tail(EuStockMarkets)
```

```{r}
start(EuStockMarkets)
```

I believed the second index in the output of start/end is the (number of rows - 1) having the given time index. 

This is what the documentation says: 
start: the time of the first observation. Either a single number or a vector of two integers, which specify a natural time unit and a (1-based) number of samples into the time unit.
(so, counting numbers of spacings?)

```{r}
end(EuStockMarkets)
```


```{r}
frequency(EuStockMarkets)
```
```{r}
deltat(EuStockMarkets)
```

```{r}
time(EuStockMarkets)
```
```{r}
plot(EuStockMarkets)
```
```{r}
ts.plot(EuStockMarkets, col = 1:4, xlab = "Year", ylab = "Index Value", main = "Major European Stock Indices, 1991-1998")
legend("topleft", colnames(EuStockMarkets), lty = 1, col = 1:4)
```


***** White Noise *****

```{r}
list(order = c(0,0,0))
```

```{r}
white_noise <- arima.sim(model = list(order = c(0,0,0)), n = 100)
print(white_noise)
```

```{r}
is.ts(white_noise)
```
```{r}
ts.plot(white_noise)
```

```{r}
white_noise2 <- arima.sim(model = list(c(0,0,0)), n = 100, mean = 100, sd = 20)
ts.plot(white_noise2)
```

```{r}
white_noise11 <- arima.sim(model = list(order = c(0, 0, 0)), n = 100)
white_noise22 <- arima.sim(model = list(c(0, 0, 0)), n = 100)
white_noise33 <- arima.sim(model = list(order2 = c(0, 0, 0)), n = 100)
```

```{r}
white_noise11 - white_noise33
```
```{r}
white_noisea <- arima.sim(model = list(order = c(0, 0, 0)), n = 100)
white_noiseb <- arima.sim(model = list(order = c(0, 0, 0)), n = 100)
white_noisea - white_noiseb
```

Moral of the exercise above: it's not necessary to call order = .. inside the list function.  Also each call of the function generates a different series.
Correction: The random walk simulation below shows that the order is needed.  Surprisingly it doesn't matter if it's called order2, orderA etc. But orde is not OK.  

An ARIMA(p, d, q) model has three parts, the auto regressive order p, the order of integration (or differencing) d, and the moving average order q. 
The ARIMA(0, 0, 0) model is the white noise model. 


*** Random Walk ** 

The random walk (RW) model is the cumulative sum (or integration) of a mean zero white noise (WN) series, such that the first difference series of a RW is a WN series.  

RW is an ARIMA(0, 1, 0) model.

```{r}
random_walk <- arima.sim(model = list(order = c(0, 1, 0)), n = 100)
ts.plot(random_walk)
```

```{r}
ts.plot(diff(random_walk))
```

Random walk with a drift

```{r}
rw_drift <- arima.sim(model = list(order = c(0, 1, 0)), n = 1000, mean = 0.1)
ts.plot(rw_drift)
```

```{r}
mean(diff(rw_drift))
```

Note: the mean doesn't match if the n is a small number (the result is not surprising).  Plotting the diff(rw_drift) is another great way of looking at it. 

Estimating the RW model

```{r}
rw_drift_diff <- diff(rw_drift)
ts.plot(rw_drift_diff)
```

```{r}
model_wn <- arima(rw_drift_diff, order = c(0, 0, 0))
model_wn
```

```{r}
model_wn$coef
```

```{r}
int_wn <- model_wn$coef
```

```{r}
ts.plot(rw_drift)
abline(0, int_wn)
```

*** Exploring Stationarity **

```{r}
white_noise <- arima.sim(model = list(order = c(0, 0, 0)), n = 100)

random_walk <- cumsum(white_noise)

wn_drift <- arima.sim(model = list(order = c(0, 0, 0)), n = 100, mean = 0.4)

rw_drift <- cumsum(wn_drift)

plot.ts(cbind(white_noise, random_walk, wn_drift, rw_drift))
```

```{r}
EuStockMarkets[-1860,]
```

*** Exploring financial time series **

```{r}
eu_percentreturns <- (EuStockMarkets[-1,] / EuStockMarkets[-1860,] - 1) * 100

head(eu_percentreturns)
```

```{r}
tail(eu_percentreturns)
```

```{r}
colMeans(eu_percentreturns)
```

```{r}
apply(eu_percentreturns, MARGIN = 2, FUN = var)
```

MARGIN = 2 tells that we want to apply the function over the columns.  FUN stands for the function

```{r}
apply(eu_percentreturns, MARGIN = 2, FUN = sd)
```

Note that var = sd^2 holds

```{r}
par(mfrow = c(2,2))
apply(eu_percentreturns, MARGIN = 2, FUN = hist, main = " ", xlab = "Percentage Return")
```

```{r}
par(mfrow = c(2,2))
apply(eu_percentreturns, MARGIN = 2, FUN = qqnorm, main = "")
qqline(eu_percentreturns)
```

From histograms, we can see that the vast majority of returns are near zero, but some daily returns are greater than 5 percentage points in magnitude.  Similarly, we see a clear departure from normality, especially in the tails of the distributions, as evident in the normal quantile plots. 
